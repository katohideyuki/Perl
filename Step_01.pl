# strict; が宣言されていると、変数がmy で宣言したプライベート変数か、パッケージ名を含めて完全に記述された変数しか使えなくなる
# 不正な変数名の使用によるクラッシュを避けるため
# 意図しない変数の利用をすぐに発見できるので、Perlのプログラムでは、必ずstrictモジュールを使うようにした方が良いらしい
use strict;

###################################
# 学習用デバッグ
###################################
# 改行用 ※あまり使わないかも
my $br = "\n";

## 引数をタイトルっぽく出力 ※引数を1つしか受け取らないなら、sihft関数をベタ書きするのが良いらしい
sub title_print {
    print $br;
    print "------------------------------------$br";
    print shift, "\n";
    print "------------------------------------$br";
}

###################################
# 変数定義
###################################
{
    # スカラー変数 ※ ひとつだけ変数に代入
    {
        &title_print("変数定義");
        my $intVal = 5;
        my $strVal = "sample";

        print "変数 intVal が生成されました : $intVal $br";
        print "変数 strVal が生成されました : $strVal $br";
        # print "$hoge";      # strictモジュールをつかっていないと、こんなhoge変数なくてもエラーにならなず実行できてしまう
    }

    # 配列
    {
        my @array = (1, 2);
        print "配列変数で2つの要素が生成されました : @array $br";

        ## インデックス 3番目に「3」をセット
        @array[2] = 3;
        print "インデックス3番目に「3」が追加されました : @array $br";
    }
}

###################################
# 最初のにマッチした文字列を取得
###################################
{
    &title_print("最初のにマッチした文字列を取得");

    ## 自作関数checkを呼び出す
    &check("book is 2000yen, cake is 800yen");
    &check("orange is 950yen");

    ## 自作関数check
    sub check{
        ### shift関数で引数の先頭を受け取り、$strに代入
        my ($str) = shift;

        ### 数値yen という文字列があれば、出力
        if ($str =~ /\d+yen/){
            print "対象文字列 : $str\nマッチした部分 : $&\n\n";
        }
    };
}

###################################
# =~ パターン演算子
###################################
{
    &title_print("=~ パターン演算子");

    ## 「=~」「!~」の使用例
    {
        my $message = "hoge";
        $message =~ /hoge/;     ### マッチすれば0を返却
        $message !~ /hoge/;     ### マッチすれば0以外を返却 ※反転式
    }

    ## 置換とかで使う場合は、取り出した変数に置換後の文字列が代入される
    {
        my $str = "My name is Mike Smith";
        $str =~ s/Mike/John/;   ### 置換後の結果が$strに代入される
        print "$str $br";
    }
}

###################################
# shift関数
###################################
## 対象となる配列の先頭の要素を取得する
## 受け取った配列に値が入っているなら、先頭を要素を取得し、要素数を1つ減らす
## 値が入っていなければ、undefを返却する。意味は違うけど、空が返ってくる的なことにしておく。
## undef関数は、一度定義したものを未定義にする関数らしい。
{
    &title_print("コマンドライン引数の受け取り方 - shift関数");

    my @city = ("tokyo", "osaka");
    
    ### @city配列の中身を出力
    print "配列に含まれる要素:\n";
    for (my $i = 0; $i <= $#city; $i++) {
        print "$city[$i]\n"
    }

    ### @city配列の先頭の要素を$valに代入し、出力
    my $val = shift(@city);
    print "\n取得した要素:\n";
    print "$val\n";

    ## 残りの要素を出力
    print "残りの要素:\n";
    for (my $i = 0; $i <= $#city; $i++) {
        print "$city[$i]\n";
    }
}
